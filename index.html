<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Karte mit Markierungen</title>
  <style>
    html, body {
      margin:0;
      font-family:system-ui, sans-serif;
      background:#fafafa;
    }

    #wrap {
      display:flex;
      flex-direction:column;
      min-height:100vh;
      max-width:100%;
    }

    header, footer {
      padding:8px 12px;
      background:#f5f5f5;
      border-bottom:1px solid #ddd;
    }
    footer {
      border-top:1px solid #ddd;
      border-bottom:none;
      font-size:0.9em;
      color:#666;
    }

    #toolbar {
      display:flex;
      gap:8px;
      align-items:center;
      flex-wrap:wrap;
    }

    .btn {
      padding:6px 10px;
      border:1px solid #ccc;
      border-radius:6px;
      background:#fff;
      cursor:pointer;
    }
    .btn:active { transform: translateY(1px); }

    .hint {
      color:#666;
      font-size:0.9em;
    }

    /* Karte-Bereich begrenzen */
    #stage {
      flex:none;
      width:100%;
      max-width:100%;
      height:80vh;               /* Karte nimmt nur einen Bereich ein */
      border:1px solid #ccc;
      background:#fff;
      overflow:hidden;           /* nichts au√üerhalb anzeigen */
      box-sizing:border-box;
    }

    #svgRoot {
      width:100%;
      height:100%;
      background:#fff;
      touch-action:none; /* besser f√ºr Interaktion */
    }

    .marker {
      cursor:grab;
    }
    .marker:active {
      cursor:grabbing;
    }
    .marker circle {
      stroke:#000;
      stroke-width:1;
      fill:rgba(255,0,0,.85);
    }

    #svgRoot * { pointer-events:visiblePainted; }
    #markerLayer { pointer-events:none; }
    #markerLayer > g { pointer-events:auto; }
  </style>
</head>
<body>
<div id="wrap">

  <header>
    <div id="toolbar">
      <button id="addMode" class="btn">‚ûï Markieren</button>
      <button id="selectMode" class="btn">üñ±Ô∏è Verschieben/L√∂schen</button>

      <label class="hint">Marker-Gr√∂√üe:
        <input id="sizeInput" type="number" step="0.05" min="0.1" value="0.2" style="width:4em;">
      </label>

      <span class="hint">
        Scroll = Zoom ‚Ä¢ Leertaste+Ziehen/Pan oder Rechtsklick+Ziehen ‚Ä¢ Shift+Klick = l√∂schen
      </span>
    </div>
  </header>

  <div id="stage">
    <svg id="svgRoot" xmlns="http://www.w3.org/2000/svg"></svg>
  </div>

  <footer>
    Marker werden automatisch mit dem Google Sheet synchronisiert.
  </footer>

</div>

<script>
(function(){
  // === Konfiguration ===
  const SVG_PATH = 'https://raw.githubusercontent.com/BattleNogare/lostparadise_halloween_2025/main/map.svg';
  const WEB_APP_URL = 'https://script.google.com/macros/s/AKfycbyUq4LMZhjRkzG2pwmNrgG1GdLjFi6H3bivz_2SEDYA0m9_lMrPQjxdFmEo0ukgdeCKKA/exec';

  // Falls du im Apps Script REQUIRE_TOKEN=true aktiviert hast:
  const TOKEN = null; // z.B. 'GEHEIM', sonst null lassen

  const STORAGE_KEY = 'markers.v1';

  // Zoom-Parameter:
  const ZOOM_FACTOR = 1.1;
  const ZOOM_MAX = 20; // max. reinzoomen (20x n√§her dran)
  let MARKER_SCALE = 0.2; // Default jetzt 0.2

  let mode = 'add';

  // viewBox State
  let svg, markerLayer;
  let vb, baseViewBox;

  // Panning State
  let isPanning = false;
  let panStart = null;
  let panStartVB = null;
  let spacePressed = false;

  // Marker: {id, px, py, label:""}
  // px/py sind Prozent relativ zur GESAMTEN Karte (baseViewBox), nicht zur aktuellen Ansicht!
  let markers = [];

  const $ = (sel, el=document) => el.querySelector(sel);

  // UI Setup
  $('#addMode').onclick = () => setMode('add');
  $('#selectMode').onclick = () => setMode('select');
  $('#sizeInput').oninput = (e) => {
    MARKER_SCALE = Math.max(0.1, parseFloat(e.target.value) || MARKER_SCALE);
    renderMarkers(); // Radius neu zeichnen
  };

  setMode('add');

  // === SVG laden und initialisieren ===
  fetch(SVG_PATH).then(r => r.text()).then(txt => {
    // eigenen Marker-Layer injizieren
    $('#svgRoot').outerHTML = txt
      .replace('<svg', '<svg id="svgRoot" style="width:100%; height:100%; touch-action:none;"')
      .replace('</svg>', '<g id="markerLayer"></g></svg>');

    svg = $('#svgRoot');
    markerLayer = $('#markerLayer');

    // Falls keine viewBox existiert ‚Üí erzeugen
    if (!svg.getAttribute('viewBox')) {
      const w = parseFloat(svg.getAttribute('width')) || 1000;
      const h = parseFloat(svg.getAttribute('height')) || 1000;
      svg.setAttribute('viewBox', `0 0 ${w} ${h}`);
    }

    // viewBox initial merken
    const [x,y,w,h] = svg.getAttribute('viewBox').split(/\s+/).map(Number);
    vb = {x,y,width:w,height:h};
    baseViewBox = {...vb}; // das ist die volle Karte, unser "Koordinatensystem"

    // Interaktion
    svg.addEventListener('click', onSvgClick);
    svg.addEventListener('wheel', onWheel, {passive:false});
    svg.addEventListener('mousedown', onMouseDown);
    window.addEventListener('mousemove', onMouseMove);
    window.addEventListener('mouseup', onMouseUp);

    // Space gedr√ºckt halten = Pan aktivieren
    window.addEventListener('keydown', (e)=>{
      if (e.code==='Space') { spacePressed=true; e.preventDefault(); }
    });
    window.addEventListener('keyup', (e)=>{
      if (e.code==='Space') { spacePressed=false; }
    });

    // Rechtsklick-Men√º blocken nur w√§hrend aktivem Panning
    window.addEventListener('contextmenu', (e)=>{
      if (isPanning) e.preventDefault();
    });

    // Marker initial aus Sheet laden (Fallback localStorage falls kein Zugriff)
    loadFromSheet().catch(()=>{
      loadLocal();
      renderMarkers();
    });
  });

  // === Modus Umschalten ===
  function setMode(m){
    mode = m;
    $('#addMode').style.fontWeight = (m==='add') ? '600' : '400';
    $('#selectMode').style.fontWeight = (m==='select') ? '600' : '400';
  }

  // === Koordinaten-Helfer ===
  // Wir wollen: Marker speichern relativ zur GESAMTEN Karte (baseViewBox),
  // nicht relativ zur aktuellen Ansicht.
  // => px/py = Prozent der baseViewBox
  function clientToBasePercent(evt) {
    // client (Maus) -> SVG-Koordinaten (absolute Karte)
    const pt = svg.createSVGPoint();
    pt.x = evt.clientX;
    pt.y = evt.clientY;
    const sp = pt.matrixTransform(svg.getScreenCTM().inverse());

    // jetzt in Prozent relativ zur vollen Karte (baseViewBox)
    const px = (sp.x - baseViewBox.x) / baseViewBox.width  * 100;
    const py = (sp.y - baseViewBox.y) / baseViewBox.height * 100;

    return {px, py};
  }

  // Aus gespeicherten Prozentwerten wieder absolute Kartenkoordinate berechnen
  function percentToAbsXY(m){
    const absX = baseViewBox.x + (m.px/100)*baseViewBox.width;
    const absY = baseViewBox.y + (m.py/100)*baseViewBox.height;
    return {absX, absY};
  }

  // === Marker-Logik ===
  function onSvgClick(evt){
    if (mode !== 'add') return;
    // Klick auf existierenden Marker soll keinen neuen erzeugen
    if (evt.target.closest && evt.target.closest('#markerLayer')) return;

    // neue Marker-Position in % der Gesamtkarte
    const {px, py} = clientToBasePercent(evt);
    const m = addMarker(px, py, "");

    renderMarkers();
    saveLocal();
    upsertRemote(m).catch(()=>{});
  }

  function addMarker(px, py, label){
    const id = crypto.randomUUID ? crypto.randomUUID() : 'm'+Date.now()+Math.random();
    // clamp 0..100 zur Sicherheit
    const fixedPx = Math.min(100, Math.max(0, px));
    const fixedPy = Math.min(100, Math.max(0, py));
    const m = {id, px: fixedPx, py: fixedPy, label};
    markers.push(m);
    return m;
  }

  function renderMarkers(){
    markerLayer.innerHTML = '';

    // Radius relativ zur Kartengr√∂√üe (und von Slider skaliert)
    const baseR = Math.max(baseViewBox.width, baseViewBox.height) * 0.006 * MARKER_SCALE;

    markers.forEach(m => {
      const {absX, absY} = percentToAbsXY(m);

      const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
      g.classList.add('marker');
      g.setAttribute('data-id', m.id);

      const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
      circle.setAttribute('cx', absX);
      circle.setAttribute('cy', absY);
      circle.setAttribute('r', baseR);

      g.appendChild(circle);
      markerLayer.appendChild(g);

      // Drag & Drop (nur im select-Modus)
      let dragging = false;
      g.addEventListener('mousedown', (e) => {
        if (mode !== 'select') return;
        dragging = true;
        e.preventDefault();
      });

      window.addEventListener('mousemove', (e) => {
        if (!dragging) return;
        // neue Position in % der Gesamtkarte berechnen
        const p = clientToBasePercent(e);
        m.px = Math.min(100, Math.max(0, p.px));
        m.py = Math.min(100, Math.max(0, p.py));
        updateMarkerNode(g, m, baseR);
      });

      window.addEventListener('mouseup', () => {
        if (!dragging) return;
        dragging = false;
        saveLocal();
        upsertRemote(m).catch(()=>{});
      });

      // Shift+Klick = l√∂schen
      g.addEventListener('click', (e) => {
        if (mode !== 'select') return;
        if (e.shiftKey) {
          markers = markers.filter(x => x.id !== m.id);
          saveLocal();
          renderMarkers();
          deleteRemote(m.id).catch(()=>{});
        }
        e.stopPropagation();
      });
    });
  }

  function updateMarkerNode(g, m, rOverride){
    const {absX, absY} = percentToAbsXY(m);
    const circle = g.querySelector('circle');
    circle.setAttribute('cx', absX);
    circle.setAttribute('cy', absY);
    if (rOverride != null) {
      circle.setAttribute('r', rOverride);
    }
  }

  // === Zoom & Pan mit Begrenzung ===
  // Begrenzung: du kannst nicht weiter rauszoomen als die ganze Karte,
  // und Panning bleibt immer im Kartenausschnitt.

  function clampAndSetViewBox(x,y,w,h){
    // Begrenze Zoom-Out: nie gr√∂√üer als ganze Karte
    if (w > baseViewBox.width)  w = baseViewBox.width;
    if (h > baseViewBox.height) h = baseViewBox.height;

    // Begrenze Pan: ViewBox muss in der Karte bleiben
    const minX = baseViewBox.x;
    const maxX = baseViewBox.x + baseViewBox.width  - w;
    const minY = baseViewBox.y;
    const maxY = baseViewBox.y + baseViewBox.height - h;

    if (x < minX) x = minX;
    if (x > maxX) x = maxX;
    if (y < minY) y = minY;
    if (y > maxY) y = maxY;

    vb = {x,y,width:w,height:h};
    svg.setAttribute('viewBox', `${x} ${y} ${w} ${h}`);

    // Wichtig: Marker m√ºssen NICHT neu gezeichnet werden.
    // Sie liegen in absoluten Kartenkoordinaten und bewegen/zoomen automatisch mit.
  }

  function onWheel(e){
    e.preventDefault();

    // Karten-Koordinate unter der Maus
    const pt = svg.createSVGPoint();
    pt.x = e.clientX;
    pt.y = e.clientY;
    const sp = pt.matrixTransform(svg.getScreenCTM().inverse());

    // Zoom-Faktor
    const scale = (e.deltaY < 0) ? (1/ZOOM_FACTOR) : ZOOM_FACTOR;

    let newW = vb.width * scale;
    let newH = vb.height * scale;

    // Maximales Reinzoomen
    const minW = baseViewBox.width / ZOOM_MAX;
    const minH = baseViewBox.height / ZOOM_MAX;
    if (newW < minW) newW = minW;
    if (newH < minH) newH = minH;

    // Rauszoomen nur bis volle Karte
    const maxW = baseViewBox.width;
    const maxH = baseViewBox.height;
    if (newW > maxW) newW = maxW;
    if (newH > maxH) newH = maxH;

    // Zoomen auf Mauspunkt
    const kx = (sp.x - vb.x) / vb.width;
    const ky = (sp.y - vb.y) / vb.height;
    const newX = sp.x - kx * newW;
    const newY = sp.y - ky * newH;

    clampAndSetViewBox(newX, newY, newW, newH);
  }

  function onMouseDown(e){
    // Pan: Space+Linksklick ODER Rechtsklick
    if ((e.button === 0 && spacePressed) || e.button === 2) {
      isPanning = true;
      panStart = {x: e.clientX, y: e.clientY};
      panStartVB = {...vb};
      e.preventDefault();
    }
  }

  function onMouseMove(e){
    if (!isPanning) return;

    const dx = e.clientX - panStart.x;
    const dy = e.clientY - panStart.y;

    // Bildschirm-Pixel -> SVG-Units umrechnen
    const m = svg.getScreenCTM();
    const scaleX = vb.width / (m.a * svg.clientWidth);
    const scaleY = vb.height / (m.d * svg.clientHeight);

    const newX = panStartVB.x - dx * scaleX;
    const newY = panStartVB.y - dy * scaleY;

    clampAndSetViewBox(newX, newY, vb.width, vb.height);
  }

  function onMouseUp(){
    isPanning = false;
  }

  // === Persistenz lokal + Sheet ===
  function saveLocal(){
    localStorage.setItem(STORAGE_KEY, JSON.stringify(markers));
  }

  function loadLocal(){
    try {
      markers = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');
    } catch(e){
      markers = [];
    }
  }

  async function loadFromSheet(){
    const qs = TOKEN
      ? `?token=${encodeURIComponent(TOKEN)}&t=${Date.now()}`
      : `?t=${Date.now()}`;

    const res = await fetch(WEB_APP_URL + qs, {method:'GET'});
    if (!res.ok) throw new Error('GET failed');

    const data = await res.json();
    markers = Array.isArray(data.markers)
      ? data.markers.map(m => ({
          id: m.id,
          px: Number(m.px),
          py: Number(m.py),
          label: "" // wir zeigen kein Label
        }))
      : [];

    saveLocal();
    renderMarkers();
  }

  function formBody(params){
    const p = new URLSearchParams();
    Object.entries(params).forEach(([k,v]) => p.set(k, v));
    if (TOKEN) p.set('token', TOKEN);
    return p.toString();
  }

  async function upsertRemote(m){
    const res = await fetch(WEB_APP_URL, {
      method:'POST',
      headers:{'Content-Type':'application/x-www-form-urlencoded'},
      body: formBody({
        action:'upsert',
        payload: JSON.stringify({
          id: m.id,
          px: m.px,
          py: m.py,
          label: "" // leer, aber backend speichert's
        })
      })
    });
    if (!res.ok) {
      console.warn('upsert failed');
    }
  }

  async function deleteRemote(id){
    const res = await fetch(WEB_APP_URL, {
      method:'POST',
      headers:{'Content-Type':'application/x-www-form-urlencoded'},
      body: formBody({
        action:'delete',
        payload: JSON.stringify({id})
      })
    });
    if (!res.ok) {
      console.warn('delete failed');
    }
  }

})();
</script>
</body>
</html>
