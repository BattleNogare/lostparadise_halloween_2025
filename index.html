<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Karte mit Markierungen</title>
  <style>
    html, body { margin:0; height:100%; }
    #wrap { height:100%; display:flex; flex-direction:column; font-family:system-ui, sans-serif; }
    header, footer { padding:8px 12px; background:#f5f5f5; }
    #toolbar { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    #stage { flex:1; overflow:hidden; background:#fff; }
    .btn { padding:6px 10px; border:1px solid #ccc; border-radius:6px; background:#fff; cursor:pointer; }
    .btn:active { transform: translateY(1px); }
    .hint { color:#666; font-size:0.9em; }
    .marker { cursor:grab; }
    .marker:active { cursor:grabbing; }
    .marker circle { stroke:#000; stroke-width:1; fill:rgba(255,0,0,.85); }
    .marker text { font: 12px/1.2 system-ui, sans-serif; user-select:none; text-anchor:middle; dominant-baseline:hanging; }
    #svgRoot * { pointer-events:visiblePainted; }
    #markerLayer { pointer-events:none; }
    #markerLayer > g { pointer-events:auto; }
  </style>
</head>
<body>
<div id="wrap">
  <header>
    <div id="toolbar">
      <button id="addMode" class="btn">‚ûï Markieren</button>
      <button id="selectMode" class="btn">üñ±Ô∏è Verschieben/L√∂schen</button>
      <button id="reloadBtn" class="btn">‚Üª Vom Sheet laden</button>
      <button id="clearBtn" class="btn">üóëÔ∏è Alle l√∂schen</button>
      <label class="hint">Marker-Gr√∂√üe:
        <input id="sizeInput" type="number" step="0.1" min="0.1" value="1.0" style="width:4em;">
      </label>
      <span class="hint">Scroll = Zoom ‚Ä¢ Leertaste+Ziehen/Pan oder Rechtsklick+Ziehen ‚Ä¢ Shift+Klick = l√∂schen ‚Ä¢ Alt/Ctrl+Klick = Label</span>
    </div>
  </header>

  <div id="stage">
    <svg id="svgRoot" xmlns="http://www.w3.org/2000/svg" style="width:100%; height:100%;"></svg>
  </div>

  <footer>
    <span class="hint">Synchronisation mit Google Sheets (Upsert pro Marker).</span>
  </footer>
</div>

<script>
(function(){
  // === Konfiguration ===
  const SVG_PATH = 'https://raw.githubusercontent.com/BattleNogare/lostparadise_halloween_2025/main/map.svg';
  const WEB_APP_URL = 'https://script.google.com/macros/s/AKfycbyUq4LMZhjRkzG2pwmNrgG1GdLjFi6H3bivz_2SEDYA0m9_lMrPQjxdFmEo0ukgdeCKKA/exec';

  // Falls du im Apps Script REQUIRE_TOKEN=true setzt, hier das gleiche Token eintragen,
  // sonst bitte TOKEN = null lassen.
  const TOKEN = null;

  const STORAGE_KEY = 'markers.v1';
  const ZOOM_FACTOR = 1.1;
  const ZOOM_MIN = 0.5;
  const ZOOM_MAX = 20;
  let MARKER_SCALE = 1.0;

  let mode = 'add';
  let svg, vb, baseViewBox, markerLayer;
  let markers = [];
  let isPanning = false, panStart = null, panStartVB = null, spacePressed=false;

  const $ = (sel, el=document) => el.querySelector(sel);

  // UI
  $('#addMode').onclick = () => setMode('add');
  $('#selectMode').onclick = () => setMode('select');
  $('#clearBtn').onclick = clearAllRemote;
  $('#reloadBtn').onclick = loadFromSheet;
  $('#sizeInput').oninput = (e) => {
    MARKER_SCALE = Math.max(0.1, parseFloat(e.target.value) || 1.0);
    renderMarkers();
  };

  setMode('add');

  // SVG laden
  fetch(SVG_PATH).then(r => r.text()).then(txt => {
    $('#svgRoot').outerHTML = txt
      .replace('<svg', '<svg id="svgRoot" style="width:100%; height:100%;"')
      .replace('</svg>', '<g id="markerLayer"></g></svg>');
    svg = $('#svgRoot');
    markerLayer = $('#markerLayer');

    // viewBox sicherstellen
    if (!svg.getAttribute('viewBox')) {
      const w = parseFloat(svg.getAttribute('width')) || 1000;
      const h = parseFloat(svg.getAttribute('height')) || 1000;
      svg.setAttribute('viewBox', `0 0 ${w} ${h}`);
    }
    const [x,y,w,h] = svg.getAttribute('viewBox').split(/\s+/).map(Number);
    vb = {x,y,width:w,height:h};
    baseViewBox = {...vb};

    // Interaktion
    svg.addEventListener('click', onSvgClick);
    svg.addEventListener('wheel', onWheel, {passive:false});
    svg.addEventListener('mousedown', onMouseDown);
    window.addEventListener('mousemove', onMouseMove);
    window.addEventListener('mouseup', onMouseUp);

    // Space gedr√ºckt halten zum Pannen
    window.addEventListener('keydown', (e)=>{
      if (e.code==='Space') { spacePressed=true; e.preventDefault(); }
    });
    window.addEventListener('keyup', (e)=>{
      if (e.code==='Space') { spacePressed=false; }
    });

    // Rechtsklick-Men√º blocken nur wenn wir gerade mitten im Panning sind
    window.addEventListener('contextmenu', (e)=>{
      if (isPanning) e.preventDefault();
    });

    // Erstmal remote laden. Wenn das fehlschl√§gt, fallback localStorage.
    loadFromSheet().catch(()=>{
      loadLocal();
      renderMarkers();
    });
  });

  function setMode(m){
    mode = m;
    $('#addMode').style.fontWeight = (m==='add') ? '600' : '400';
    $('#selectMode').style.fontWeight = (m==='select') ? '600' : '400';
  }

  // === Koordinaten / Marker

  function clientToSvgPercent(evt) {
    const pt = svg.createSVGPoint();
    pt.x = evt.clientX; pt.y = evt.clientY;
    const sp = pt.matrixTransform(svg.getScreenCTM().inverse());
    const px = (sp.x - vb.x) / vb.width * 100;
    const py = (sp.y - vb.y) / vb.height * 100;
    return {px, py};
  }

  function onSvgClick(evt){
    if (mode !== 'add') return;
    // Klick auf bestehenden Marker soll NICHT neuen Marker machen
    if (evt.target.closest && evt.target.closest('#markerLayer')) return;

    const {px, py} = clientToSvgPercent(evt);
    const label = prompt('Optional: Label/Notiz', '') || '';
    const m = addMarker(px, py, label);
    renderMarkers();
    saveLocal();
    upsertRemote(m).catch(()=>{});
  }

  function addMarker(px, py, label=''){
    const id = crypto.randomUUID ? crypto.randomUUID() : 'm'+Date.now()+Math.random();
    const m = {id, px, py, label};
    markers.push(m);
    return m;
  }

  function renderMarkers(){
    markerLayer.innerHTML = '';
    // Marker-Radius h√§ngt von der Grundkarte ab + deinem Scale-Faktor
    const baseR = Math.max(baseViewBox.width, baseViewBox.height) * 0.006 * MARKER_SCALE;

    markers.forEach(m => {
      const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
      g.classList.add('marker');
      g.setAttribute('data-id', m.id);

      const cx = vb.x + (m.px/100)*vb.width;
      const cy = vb.y + (m.py/100)*vb.height;

      const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
      circle.setAttribute('cx', cx);
      circle.setAttribute('cy', cy);
      circle.setAttribute('r', baseR);

      const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      text.setAttribute('x', cx);
      text.setAttribute('y', cy);
      text.textContent = m.label || '‚óè';

      g.appendChild(circle);
      g.appendChild(text);
      markerLayer.appendChild(g);

      // Drag & Drop nur im select-Modus
      let dragging = false;
      g.addEventListener('mousedown', (e) => {
        if (mode !== 'select') return;
        dragging = true;
        e.preventDefault();
      });

      window.addEventListener('mousemove', (e) => {
        if (!dragging) return;
        const p = clientToSvgPercent(e);
        m.px = Math.min(100, Math.max(0, p.px));
        m.py = Math.min(100, Math.max(0, p.py));
        updateMarkerNode(g, m, baseR);
      });

      window.addEventListener('mouseup', () => {
        if (!dragging) return;
        dragging = false;
        saveLocal();
        upsertRemote(m).catch(()=>{});
      });

      // Klick-Interaktion im select-Modus
      g.addEventListener('click', (e) => {
        if (mode !== 'select') return;

        // SHIFT+Klick -> l√∂schen
        if (e.shiftKey) {
          markers = markers.filter(x => x.id !== m.id);
          saveLocal();
          renderMarkers();
          deleteRemote(m.id).catch(()=>{});
        }
        // Alt / Ctrl / Cmd -> Label bearbeiten
        else if (e.altKey || e.metaKey || e.ctrlKey) {
          const newLabel = prompt('Label bearbeiten', m.label) ?? m.label;
          m.label = newLabel;
          saveLocal();
          updateMarkerNode(g, m, baseR);
          upsertRemote(m).catch(()=>{});
        }

        e.stopPropagation();
      });

    });
  }

  function updateMarkerNode(g, m, rOverride=null){
    const cx = vb.x + (m.px/100)*vb.width;
    const cy = vb.y + (m.py/100)*vb.height;
    const circle = g.querySelector('circle');
    const text = g.querySelector('text');

    circle.setAttribute('cx', cx);
    circle.setAttribute('cy', cy);
    if (rOverride != null) {
      circle.setAttribute('r', rOverride);
    }

    text.setAttribute('x', cx);
    text.setAttribute('y', cy);
    text.textContent = m.label || '‚óè';
  }

  // === Zoom & Pan

  function setViewBox(x,y,w,h){
    vb = {x,y,width:w,height:h};
    svg.setAttribute('viewBox', `${x} ${y} ${w} ${h}`);
    renderMarkers(); // neu platzieren
  }

  function onWheel(e){
    e.preventDefault();

    // Weltkoordinate unter dem Mauszeiger
    const pt = svg.createSVGPoint();
    pt.x = e.clientX;
    pt.y = e.clientY;
    const sp = pt.matrixTransform(svg.getScreenCTM().inverse());

    const scale = (e.deltaY < 0) ? (1/ZOOM_FACTOR) : ZOOM_FACTOR;
    let newW = vb.width * scale;
    let newH = vb.height * scale;

    // harte Zoom-Grenzen
    const minW = baseViewBox.width / ZOOM_MAX;
    const maxW = baseViewBox.width / ZOOM_MIN;
    newW = Math.min(Math.max(newW, minW), maxW);
    newH = newW * (vb.height / vb.width);

    // zoome auf den Punkt unter dem Mauszeiger
    const kx = (sp.x - vb.x) / vb.width;
    const ky = (sp.y - vb.y) / vb.height;
    const newX = sp.x - kx * newW;
    const newY = sp.y - ky * newH;

    setViewBox(newX, newY, newW, newH);
  }

  function onMouseDown(e){
    // Pan: Space+Linksklick ODER Rechtsklick
    if ((e.button === 0 && spacePressed) || e.button === 2) {
      isPanning = true;
      panStart = {x: e.clientX, y: e.clientY};
      panStartVB = {...vb};
      e.preventDefault();
    }
  }

  function onMouseMove(e){
    if (!isPanning) return;
    const dx = e.clientX - panStart.x;
    const dy = e.clientY - panStart.y;

    // Bildschirm-Pixel -> SVG-Units
    const m = svg.getScreenCTM();
    const scaleX = vb.width / (m.a * svg.clientWidth);
    const scaleY = vb.height / (m.d * svg.clientHeight);

    setViewBox(
      panStartVB.x - dx * scaleX,
      panStartVB.y - dy * scaleY,
      vb.width,
      vb.height
    );
  }

  function onMouseUp(){
    isPanning = false;
  }

  // === Persistenz

  function saveLocal(){
    localStorage.setItem(STORAGE_KEY, JSON.stringify(markers));
  }
  function loadLocal(){
    try {
      markers = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');
    } catch(e){
      markers = [];
    }
  }

  function buildBody(params){
    const p = new URLSearchParams();
    Object.entries(params).forEach(([k,v]) => p.set(k, v));
    if (TOKEN) p.set('token', TOKEN); // shared secret optional
    return p.toString();
  }

  async function loadFromSheet(){
    // Cache-Buster mit ?t=Timestamp, optional token
    const qs = TOKEN
      ? `?token=${encodeURIComponent(TOKEN)}&t=${Date.now()}`
      : `?t=${Date.now()}`;

    const res = await fetch(WEB_APP_URL + qs, {method:'GET'});
    if (!res.ok) throw new Error('GET failed');

    const data = await res.json();
    markers = Array.isArray(data.markers)
      ? data.markers.map(m => ({
          id: m.id,
          px: Number(m.px),
          py: Number(m.py),
          label: m.label || ''
        }))
      : [];

    saveLocal();
    renderMarkers();
  }

  async function upsertRemote(m){
    const res = await fetch(WEB_APP_URL, {
      method:'POST',
      headers:{'Content-Type':'application/x-www-form-urlencoded'},
      body: buildBody({
        action:'upsert',
        payload: JSON.stringify(m)
      })
    });
    if (!res.ok) {
      console.warn('upsert failed');
    }
  }

  async function deleteRemote(id){
    const res = await fetch(WEB_APP_URL, {
      method:'POST',
      headers:{'Content-Type':'application/x-www-form-urlencoded'},
      body: buildBody({
        action:'delete',
        payload: JSON.stringify({id})
      })
    });
    if (!res.ok) {
        console.warn('delete failed');
    }
  }

  async function clearAllRemote(){
    if (!confirm('Alle Marker im Sheet l√∂schen?')) return;

    const res = await fetch(WEB_APP_URL, {
      method:'POST',
      headers:{'Content-Type':'application/x-www-form-urlencoded'},
      body: buildBody({
        action:'clearAll'
      })
    });

    if (!res.ok) {
      alert('L√∂schen fehlgeschlagen');
      return;
    }

    markers = [];
    saveLocal();
    renderMarkers();
  }

})();
</script>
</body>
</html>
