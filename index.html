<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Karte mit Markierungen</title>

  <!-- Favicon -->
  <link rel="icon" type="image/x-icon" href="https://raw.githubusercontent.com/BattleNogare/lostparadise_halloween_2025/main/halloween_fav.ico">

  <style>
    html, body {
      margin:0;
      font-family:system-ui, sans-serif;
      background:#fafafa;
      height:100%;
    }

    #wrap {
      display:flex;
      flex-direction:column;
      min-height:100vh;
      max-width:100%;
    }

    /* Header */
    header {
      padding:8px 12px;
      background:#f5f5f5;
      border-bottom:1px solid #ddd;
      display:flex;
      align-items:center;
      justify-content:space-between;
      flex-wrap:wrap;
      row-gap:8px;
    }

    #toolbar {
      display:flex;
      gap:12px;
      align-items:center;
      flex-wrap:wrap;
      max-width:calc(100% - 60px); /* Platz fürs Logo rechts lassen */
    }

    .hint {
      color:#444;
      font-size:0.8rem;
      line-height:1.4;
      max-width:600px;
    }

    /* Logo rechts oben */
    #logo {
      display:flex;
      align-items:center;
      justify-content:center;
      height:40px;
      flex:none;
    }
    #logo img {
      height:40px;
      width:auto;
      display:block;
    }

    /* Hauptbereich */
    #main {
      flex:1;
      display:flex;
      min-height:0;
      padding:12px;
      gap:12px;
      box-sizing:border-box;
    }

    /* Karte mit Rahmen */
    #stageWrapper {
      flex:1;
      min-width:0;
      display:flex;
    }

    #stage {
      flex:1;
      border:3px solid #333;
      border-radius:10px;
      background:#fff;
      overflow:hidden;
      height:80vh;
      max-height:80vh;
      max-width:100%;
      position:relative;
      box-shadow:0 0 10px rgba(0,0,0,0.15);
    }

    #svgRoot {
      width:100%;
      height:100%;
      background:#fff;
      touch-action:none; /* blockt Browser-Scroll/Gesten auf Touch */
    }

    /* History rechts */
    #history {
      width:240px;
      max-width:240px;
      flex:none;
      display:flex;
      flex-direction:column;
      border:1px solid #ccc;
      border-radius:8px;
      background:#fff;
      max-height:80vh;
      box-shadow:0 0 6px rgba(0,0,0,0.1);
      font-size:0.9rem;
      line-height:1.4;
    }

    #historyHeader {
      padding:8px 10px;
      border-bottom:1px solid #ddd;
      font-weight:600;
      background:#f5f5f5;
      text-align:center;
      font-size:0.9rem;
    }

    #historyList {
      flex:1;
      overflow:auto;
      padding:8px 10px;
    }

    .historyItem {
      padding:6px 8px;
      border-radius:4px;
      cursor:grab;
      user-select:none;
      border:1px solid transparent;
      margin-bottom:6px;
      background:#fff;
      font-size:0.85rem;
    }
    .historyItem:hover {
      background:#eee;
    }

    /* Marker Styles */
    .marker {
      cursor:grab;
    }
    .marker:active {
      cursor:grabbing;
    }

    .marker circle {
      stroke:#000;
      stroke-width:1;
      fill:rgba(255,0,0,.85);
      transition:fill .1s, stroke .1s, stroke-width .1s;
    }

    /* Hervorhebung aus History */
    .marker.highlight circle {
      fill:rgba(255,255,0,.6);
      stroke:#ff0;
      stroke-width:3;
    }

    /* Interaktionsebene */
    #svgRoot * { pointer-events:visiblePainted; }
    #markerLayer { pointer-events:none; }
    #markerLayer > g { pointer-events:auto; }
  </style>
</head>
<body>
<div id="wrap">

  <header>
    <div id="toolbar">
      <div class="hint">
        Shift + Linksklick = Marker setzen •
        Linksklick halten = verschieben •
        Shift + Rechtsklick = löschen (ausblenden) •
        Scroll = Zoom •
        Leertaste+Ziehen / Rechtsklick+Ziehen = Pan
      </div>
    </div>

    <!-- Logo rechts -->
    <div id="logo">
      <img src="https://raw.githubusercontent.com/BattleNogare/lostparadise_halloween_2025/main/halloween.png" alt="Halloween Logo">
    </div>
  </header>

  <div id="main">
    <div id="stageWrapper">
      <div id="stage">
        <svg id="svgRoot" xmlns="http://www.w3.org/2000/svg"></svg>
      </div>
    </div>

    <aside id="history">
      <div id="historyHeader">History</div>
      <div id="historyList"></div>
    </aside>
  </div>

</div>

<script>
(function(){
  // === Konfiguration ===
  const SVG_PATH = 'https://raw.githubusercontent.com/BattleNogare/lostparadise_halloween_2025/main/map.svg';
  const WEB_APP_URL = 'https://script.google.com/macros/s/AKfycbyUq4LMZhjRkzG2pwmNrgG1GdLjFi6H3bivz_2SEDYA0m9_lMrPQjxdFmEo0ukgdeCKKA/exec';

  // Falls du im Apps Script REQUIRE_TOKEN=true aktivierst:
  const TOKEN = null; // z.B. 'GEHEIM', sonst null lassen

  const STORAGE_KEY = 'markers.v1';

  // Zoom-Einstellungen
  const ZOOM_FACTOR = 1.4; // höher = schnelleres Scroll-Zoomen
  const ZOOM_MAX = 20;     // maximaler Zoom in die Karte

  // Dynamische Markerskalierung:
  // bei komplett rausgezoomt (zoomFactor=1) => größer (~1.0)
  // bei maximal reingezoomt (zoomFactor=ZOOM_MAX) => klein (0.2)
  const SCALE_OUT = 1.0;
  const SCALE_IN  = 0.2;

  let svg, markerLayer;
  let vb, baseViewBox;

  // Pan / Drag
  let isPanning = false;
  let panStart = null;
  let panStartVB = null;
  let spacePressed = false;

  // Marker-Liste:
  // { id, px, py, visible, createdAt }
  // px/py = Prozent relativ zur gesamten Karte (baseViewBox)
  let markers = [];

  // Map MarkerID -> SVG-<g>-Node (für History-Highlight)
  let markerDomMap = {};

  // Auto-inkrementierende IDs (0001, 0002, …)
  let nextIdNumber = 1;
  function getNextId(){
    const idStr = String(nextIdNumber).padStart(4,'0');
    nextIdNumber++;
    return idStr;
  }

  const $ = (sel, el=document) => el.querySelector(sel);

  // === SVG laden & initialisieren ===
  fetch(SVG_PATH)
    .then(r => r.text())
    .then(txt => {
      // eigenen Marker-Layer einfügen
      $('#svgRoot').outerHTML = txt
        .replace('<svg', '<svg id="svgRoot" style="width:100%; height:100%; touch-action:none;"')
        .replace('</svg>', '<g id="markerLayer"></g></svg>');

      svg = $('#svgRoot');
      markerLayer = $('#markerLayer');

      // Kein Browser-Kontextmenü innerhalb der Karte:
      // blockiere contextmenu auf dem Stage-Bereich und dem SVG
      const stageEl = document.getElementById('stage');
      stageEl.addEventListener('contextmenu', e => e.preventDefault());
      svg.addEventListener('contextmenu', e => e.preventDefault());

      // viewBox sicherstellen
      if (!svg.getAttribute('viewBox')) {
        const w = parseFloat(svg.getAttribute('width')) || 1000;
        const h = parseFloat(svg.getAttribute('height')) || 1000;
        svg.setAttribute('viewBox', `0 0 ${w} ${h}`);
      }

      // initiale viewBox merken
      const [x,y,w,h] = svg.getAttribute('viewBox').split(/\s+/).map(Number);
      vb = {x,y,width:w,height:h};
      baseViewBox = {...vb}; // komplette Karte

      // Interaktionen fürs SVG
      svg.addEventListener('click', onSvgClickAdd);          // Shift+Linksklick = neuen Marker setzen
      svg.addEventListener('wheel', onWheel, {passive:false});
      svg.addEventListener('mousedown', onMouseDownPanOrMarkerStart);
      window.addEventListener('mousemove', onMouseMoveAll);
      window.addEventListener('mouseup', onMouseUpAll);

      // Space gedrückt halten => Pan mit linker Taste erlaubt
      window.addEventListener('keydown', (e)=>{
        if (e.code==='Space') { spacePressed=true; e.preventDefault(); }
      });
      window.addEventListener('keyup', (e)=>{
        if (e.code==='Space') { spacePressed=false; }
      });

      // Marker vom Sheet laden; Fallback localStorage
      loadFromSheet().catch(()=>{
        loadLocal();
        updateNextIdFromMarkers();
        renderMarkers();
      });
    });

  // Hilfsfunktion: nach Laden aus Sheet / local den nextIdNumber hochsetzen
  function updateNextIdFromMarkers(){
    const idsNum = markers
      .map(m => parseInt(m.id,10))
      .filter(n => !isNaN(n));
    nextIdNumber = (idsNum.length ? Math.max(...idsNum)+1 : 1);
  }

  // --- Koordinaten-Helfer ---
  // Mauskoordinate → Prozent relativ zur ganzen Karte
  function clientToBasePercent(evt) {
    const pt = svg.createSVGPoint();
    pt.x = evt.clientX;
    pt.y = evt.clientY;
    const sp = pt.matrixTransform(svg.getScreenCTM().inverse());

    const px = (sp.x - baseViewBox.x) / baseViewBox.width  * 100;
    const py = (sp.y - baseViewBox.y) / baseViewBox.height * 100;

    return {
      px: Math.min(100, Math.max(0, px)),
      py: Math.min(100, Math.max(0, py))
    };
  }

  // Prozent → absolute Kartenkoordinaten
  function percentToAbsXY(m){
    const absX = baseViewBox.x + (m.px/100)*baseViewBox.width;
    const absY = baseViewBox.y + (m.py/100)*baseViewBox.height;
    return {absX, absY};
  }

  // --- Dynamische Marker-Radius-Berechnung je nach Zoom ---
  // Wir bestimmen den aktuellen Zoom-Faktor:
  // zoomFactor = baseWidth / currentWidth
  //  -> 1   bedeutet komplett rausgezoomt
  //  -> ZOOM_MAX bedeutet maximal reingezoomt
  // Dann interpolieren wir zwischen SCALE_OUT (z.B. 1.0) und SCALE_IN (0.2)
  function getCurrentMarkerRadius(){
    const zoomFactor = baseViewBox.width / vb.width; // 1 .. ZOOM_MAX
    const t = (zoomFactor - 1) / (ZOOM_MAX - 1);      // 0 .. 1
    const scaleNow = SCALE_OUT*(1 - t) + SCALE_IN*t;  // lerp

    // Baseline-Radius hängt von Kartengröße ab
    const baseLen = Math.max(baseViewBox.width, baseViewBox.height);
    return baseLen * 0.006 * scaleNow;
  }

  // --- Marker erstellen / zeichnen / sync ---
  // Shift + Linksklick auf freie Karte = neuen Marker setzen
  function onSvgClickAdd(evt){
    if (!evt.shiftKey) return; // nur mit Shift
    // Falls Klick eigentlich auf einem Marker war, kein neuer
    if (evt.target.closest && evt.target.closest('#markerLayer')) return;

    const {px, py} = clientToBasePercent(evt);
    const m = createMarker(px, py);
    saveLocal();
    upsertRemote(m);
    renderMarkers();
  }

  function createMarker(px, py){
    const id = getNextId();
    const m = {
      id,
      px,
      py,
      visible: 1,
      createdAt: Date.now()
    };
    markers.push(m);
    return m;
  }

  function renderMarkers(){
    markerLayer.innerHTML = '';
    markerDomMap = {};

    const dynamicR = getCurrentMarkerRadius();

    markers
      .filter(m => m.visible !== 0)
      .forEach(m => {
        const {absX, absY} = percentToAbsXY(m);

        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        g.classList.add('marker');
        g.setAttribute('data-id', m.id);

        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        circle.setAttribute('cx', absX);
        circle.setAttribute('cy', absY);
        circle.setAttribute('r', dynamicR);

        g.appendChild(circle);
        markerLayer.appendChild(g);

        markerDomMap[m.id] = g;

        attachMarkerInteractions(g, m);
      });

    rebuildHistory();
  }

  // Interaktion auf einem einzelnen Marker:
  // - Linksklick halten = verschieben (Drag)
  // - Shift + Rechtsklick = ausblenden (löschen/visible=0)
  function attachMarkerInteractions(g, m){
    let dragging = false;

    g.addEventListener('mousedown', (e) => {
      // Linke Maustaste -> Drag starten (wenn NICHT Shift)
      if (e.button === 0 && !e.shiftKey) {
        dragging = true;
        e.preventDefault();
      }

      // Rechte Maustaste + Shift -> ausblenden
      if (e.button === 2 && e.shiftKey) {
        e.preventDefault();
        m.visible = 0; // "löschen" in UI, aber nur ausblenden
        saveLocal();
        upsertRemote(m);
        renderMarkers();
      }
    });

    // wir speichern interne Flags am DOM-Knoten,
    // damit globale mousemove/mouseup sie finden können
    g._dragMarkerRef = m;
    g._isDragging    = () => dragging;
    g._stopDragging  = () => { dragging = false; };
  }

  // während Drag: Marker-Position live updaten
  function dragMoveMarkerIfNeeded(evt){
    for (const id in markerDomMap){
      const g = markerDomMap[id];
      const m = markers.find(mm => mm.id === id);
      if (!m) continue;
      if (!g._isDragging || !g._isDragging()) continue;

      const p = clientToBasePercent(evt);
      m.px = p.px;
      m.py = p.py;

      // Update nur die Position des Kreises:
      const {absX, absY} = percentToAbsXY(m);
      const circle = g.querySelector('circle');
      circle.setAttribute('cx', absX);
      circle.setAttribute('cy', absY);
    }
  }

  // Drag beenden -> speichern + sync + rerender (inkl. History)
  function dragStopIfNeeded(){
    for (const id in markerDomMap){
      const g = markerDomMap[id];
      const m = markers.find(mm => mm.id === id);
      if (!m) continue;
      if (!g._isDragging || !g._isDragging()) continue;

      g._stopDragging();
      saveLocal();
      upsertRemote(m);
      renderMarkers();
    }
  }

  // --- History ---
  // Zeigt nur sichtbare Marker, neueste oben.
  // Beim Gedrückthalten eines Eintrags wird der Marker gelb hervorgehoben.
  function rebuildHistory(){
    const listEl = $('#historyList');
    listEl.innerHTML = '';

    const visibleMarkers = markers
      .filter(m => m.visible !== 0)
      .slice()
      .sort((a,b) => b.createdAt - a.createdAt);

    visibleMarkers.forEach(m => {
      const item = document.createElement('div');
      item.className = 'historyItem';
      item.textContent = 'Marker ' + m.id;
      item.dataset.id = m.id;

      let pressed = false;

      item.addEventListener('mousedown', (e) => {
        if (e.button !== 0) return;
        pressed = true;
        highlightMarker(m.id, true);
        e.preventDefault();
      });

      window.addEventListener('mouseup', () => {
        if (!pressed) return;
        pressed = false;
        highlightMarker(m.id, false);
      });

      listEl.appendChild(item);
    });
  }

  function highlightMarker(id, on){
    const g = markerDomMap[id];
    if (!g) return;
    if (on) g.classList.add('highlight');
    else g.classList.remove('highlight');
  }

  // --- Pan & Zoom mit Begrenzung ---
  // - Raus nur bis gesamte Karte
  // - Panning bleibt innerhalb der Karte
  // UND: wir rendern Marker nach jedem Zoom neu,
  // damit die Größe (Radius) dynamisch dem Zoom folgt.
  function clampAndSetViewBox(x,y,w,h){
    // Begrenze Zoom-Out
    if (w > baseViewBox.width)  w = baseViewBox.width;
    if (h > baseViewBox.height) h = baseViewBox.height;

    // Begrenze Pan
    const minX = baseViewBox.x;
    const maxX = baseViewBox.x + baseViewBox.width  - w;
    const minY = baseViewBox.y;
    const maxY = baseViewBox.y + baseViewBox.height - h;

    if (x < minX) x = minX;
    if (x > maxX) x = maxX;
    if (y < minY) y = minY;
    if (y > maxY) y = maxY;

    const sizeChanged = (w !== vb.width || h !== vb.height);

    vb = {x,y,width:w,height:h};
    svg.setAttribute('viewBox', `${x} ${y} ${w} ${h}`);

    // Markergröße hängt vom Zoom ab.
    // Wir aktualisieren bei Zoom. Bei reinem Pan ändert sich w/h nicht -> optional könntest du das sparen.
    if (sizeChanged) {
      renderMarkers();
    } else {
      // Bei Pan müssen Marker nicht neu gerendert werden, sie bleiben an der Stelle.
    }
  }

  // Scrollrad-Zoom
  function onWheel(e){
    e.preventDefault();

    // Karten-Koordinate unter der Maus
    const pt = svg.createSVGPoint();
    pt.x = e.clientX;
    pt.y = e.clientY;
    const sp = pt.matrixTransform(svg.getScreenCTM().inverse());

    // Zoom-Faktor (rein/raus)
    const scale = (e.deltaY < 0) ? (1/ZOOM_FACTOR) : ZOOM_FACTOR;

    let newW = vb.width * scale;
    let newH = vb.height * scale;

    // Maximales Reinzoomen
    const minW = baseViewBox.width / ZOOM_MAX;
    const minH = baseViewBox.height / ZOOM_MAX;
    if (newW < minW) newW = minW;
    if (newH < minH) newH = minH;

    // Raus nur bis ganze Karte
    const maxW = baseViewBox.width;
    const maxH = baseViewBox.height;
    if (newW > maxW) newW = maxW;
    if (newH > maxH) newH = maxH;

    // Zoomen auf Mausposition ausrichten
    const kx = (sp.x - vb.x) / vb.width;
    const ky = (sp.y - vb.y) / vb.height;
    const newX = sp.x - kx * newW;
    const newY = sp.y - ky * newH;

    clampAndSetViewBox(newX, newY, newW, newH);
  }

  // --- Pan / Drag global ---
  function onMouseDownPanOrMarkerStart(e){
    // Pan: Space+Linksklick ODER Rechtsklick (ohne Shift)
    if ((e.button === 0 && spacePressed) ||
        (e.button === 2 && !e.shiftKey)) {
      isPanning = true;
      panStart = {x:e.clientX, y:e.clientY};
      panStartVB = {...vb};
      e.preventDefault();
    }
  }

  function onMouseMoveAll(e){
    // falls gerade ein Marker gezogen wird, bewege ihn
    dragMoveMarkerIfNeeded(e);

    // Pan?
    if (!isPanning) return;

    const dx = e.clientX - panStart.x;
    const dy = e.clientY - panStart.y;

    // Bildschirm-Pixel → SVG-Koordinaten
    const m = svg.getScreenCTM();
    const scaleX = vb.width  / (m.a * svg.clientWidth);
    const scaleY = vb.height / (m.d * svg.clientHeight);

    const newX = panStartVB.x - dx * scaleX;
    const newY = panStartVB.y - dy * scaleY;

    // Bei Panning ändert sich Größe nicht -> wir wollen Marker nicht jedes Pixel neu rendern.
    // Deshalb rufen wir clampAndSetViewBox auf, aber akzeptieren, dass sizeChanged=false ⇒ kein renderMarkers().
    clampAndSetViewBox(newX, newY, vb.width, vb.height);
  }

  function onMouseUpAll(){
    // Pan beenden
    isPanning = false;
    // evtl. Drag eines Markers beenden
    dragStopIfNeeded();
  }

  // --- Persistenz lokal & Sheets ---
  function saveLocal(){
    localStorage.setItem(STORAGE_KEY, JSON.stringify(markers));
  }

  function loadLocal(){
    try {
      markers = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');
    } catch(e){
      markers = [];
    }
  }

  async function loadFromSheet(){
    const qs = TOKEN
      ? `?token=${encodeURIComponent(TOKEN)}&t=${Date.now()}`
      : `?t=${Date.now()}`;

    const res = await fetch(WEB_APP_URL + qs, {method:'GET'});
    if (!res.ok) throw new Error('GET failed');

    const data = await res.json();
    markers = Array.isArray(data.markers)
      ? data.markers.map(m => ({
          id: m.id,
          px: Number(m.px),
          py: Number(m.py),
          visible: (m.visible === 0 ? 0 : 1),
          createdAt: m.createdAt ? Number(m.createdAt) : Date.now()
        }))
      : [];

    updateNextIdFromMarkers();
    saveLocal();
    renderMarkers();
  }

  function formBody(params){
    const p = new URLSearchParams();
    Object.entries(params).forEach(([k,v]) => p.set(k, v));
    if (TOKEN) p.set('token', TOKEN);
    return p.toString();
  }

  function upsertRemote(m){
    // Speichert Marker inkl. visible und createdAt
    fetch(WEB_APP_URL, {
      method:'POST',
      headers:{'Content-Type':'application/x-www-form-urlencoded'},
      body: formBody({
        action:'upsert',
        payload: JSON.stringify({
          id: m.id,
          px: m.px,
          py: m.py,
          label: "", // legacy Feld ungenutzt
          visible: (m.visible === 0 ? 0 : 1),
          createdAt: m.createdAt || Date.now()
        })
      })
    }).catch(()=>{ /* offline ok */ });
  }

})();
</script>
</body>
</html>
